"use strict";(self.webpackChunkmanifold_kb=self.webpackChunkmanifold_kb||[]).push([[2463],{3905:function(e,t,o){o.d(t,{Zo:function(){return h},kt:function(){return u}});var a=o(7294);function n(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function i(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,a)}return o}function r(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?i(Object(o),!0).forEach((function(t){n(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):i(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function s(e,t){if(null==e)return{};var o,a,n=function(e,t){if(null==e)return{};var o,a,n={},i=Object.keys(e);for(a=0;a<i.length;a++)o=i[a],t.indexOf(o)>=0||(n[o]=e[o]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)o=i[a],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(n[o]=e[o])}return n}var l=a.createContext({}),c=function(e){var t=a.useContext(l),o=t;return e&&(o="function"==typeof e?e(t):r(r({},t),e)),o},h=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var o=e.components,n=e.mdxType,i=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),d=c(o),u=n,m=d["".concat(l,".").concat(u)]||d[u]||p[u]||i;return o?a.createElement(m,r(r({ref:t},h),{},{components:o})):a.createElement(m,r({ref:t},h))}));function u(e,t){var o=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=o.length,r=new Array(i);r[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:n,r[1]=s;for(var c=2;c<i;c++)r[c]=o[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,o)}d.displayName="MDXCreateElement"},6926:function(e,t,o){o.r(t),o.d(t,{assets:function(){return h},contentTitle:function(){return l},default:function(){return u},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return p}});var a=o(7462),n=o(3366),i=(o(7294),o(3905)),r=["components"],s={created:"2022-09-19T17:23:27 (UTC -07:00)",tags:[],source:"https://notes.ethereum.org/DaWh-02HQ4qftum1xdphkg?view",author:"Alex Stokes"},l="Block production in Ethereum after the Merge - HackMD",c={unversionedId:"reference/block-production",id:"reference/block-production",title:"Block production in Ethereum after the Merge - HackMD",description:"The Ethereum protocol is about to undergo a long-awaited upgrade called \u201cthe Merge\u201d that delivers a move away from the current proof-of-work consensus to a new proof-of-stake consensus.",source:"@site/docs/reference/block-production.md",sourceDirName:"reference",slug:"/reference/block-production",permalink:"/docs/reference/block-production",draft:!1,editUrl:"https://github.com/manifoldfinance/kb/tree/trunk/docs/reference/block-production.md",tags:[],version:"current",frontMatter:{created:"2022-09-19T17:23:27 (UTC -07:00)",tags:[],source:"https://notes.ethereum.org/DaWh-02HQ4qftum1xdphkg?view",author:"Alex Stokes"},sidebar:"docsSidebar",previous:{title:"Authentication",permalink:"/docs/reference/ref-auth"},next:{title:"SushiSwap Integration and strategies",permalink:"/docs/Strategies/strat-sushiswap"}},h={},p=[{value:"A new consensus model",id:"a-new-consensus-modela-new-consensus-model",level:2},{value:"Synchronous protocol execution",id:"synchronous-protocol-executionsynchronous-protocol-execution",level:3},{value:"Deterministic, public leader election",id:"deterministic-public-leader-electiondeterministic-public-leader-election",level:3},{value:"Fork choice driven by validator set",id:"fork-choice-driven-by-validator-setfork-choice-driven-by-validator-set",level:3},{value:"A round of the consensus protocol",id:"a-round-of-the-consensus-protocola-round-of-the-consensus-protocol",level:2},{value:"Evaluating fork choice",id:"evaluating-fork-choiceevaluating-fork-choice",level:3},{value:"Block production",id:"block-productionblock-production",level:3},{value:"Broadcast block",id:"broadcast-blockbroadcast-block",level:3},{value:"Broadcast attestation",id:"broadcast-attestationbroadcast-attestation",level:3},{value:"Broadcast aggregated attestation",id:"broadcast-aggregated-attestationbroadcast-aggregated-attestation",level:3},{value:"Repeat",id:"repeatrepeat",level:3},{value:"Architecture of the Merge",id:"architecture-of-the-mergearchitecture-of-the-merge",level:2},{value:"All good things have layers",id:"all-good-things-have-layersall-good-things-have-layers",level:3},{value:"How do the layers communicate?",id:"how-do-the-layers-communicatehow-do-the-layers-communicate",level:3},{value:"Better together",id:"better-togetherbetter-together",level:3},{value:"Block production in detail",id:"block-production-in-detailblock-production-in-detail",level:2},{value:"Assembling the consensus envelope",id:"assembling-the-consensus-envelopeassembling-the-consensus-envelope",level:3},{value:"Validator inputs",id:"validator-inputsvalidator-inputs",level:4},{value:"Deterministic CL inputs",id:"deterministic-cl-inputsdeterministic-cl-inputs",level:4},{value:"Nondeterministic CL inputs",id:"nondeterministic-cl-inputsnondeterministic-cl-inputs",level:4},{value:"Orchestrating the execution payload build",id:"orchestrating-the-execution-payload-buildorchestrating-the-execution-payload-build",level:3},{value:"Assembling the execution payload",id:"assembling-the-execution-payloadassembling-the-execution-payload",level:3},{value:"Validator inputs",id:"validator-inputs1validator-inputs",level:4},{value:"Deterministic CL inputs",id:"deterministic-cl-inputs1deterministic-cl-inputs",level:4},{value:"Determinstic EL inputs",id:"determinstic-el-inputsdeterminstic-el-inputs",level:4},{value:"Nondeterministic EL inputs",id:"nondeterministic-el-inputsnondeterministic-el-inputs",level:4},{value:"Sealing the complete block",id:"sealing-the-complete-blocksealing-the-complete-block",level:3},{value:"Optimizations for block production",id:"optimizations-for-block-productionoptimizations-for-block-production",level:2},{value:"An external builder network",id:"an-external-builder-networkan-external-builder-network",level:2},{value:"A second block production pathway",id:"a-second-block-production-pathwaya-second-block-production-pathway",level:3},{value:"Further considerations",id:"further-considerationsfurther-considerations",level:2},{value:"Proposer lookahead",id:"proposer-lookaheadproposer-lookahead",level:3},{value:"Reorgs",id:"reorgsreorgs",level:3},{value:"Timing of broadcast",id:"timing-of-broadcasttiming-of-broadcast",level:3},{value:"External builder failure",id:"external-builder-failureexternal-builder-failure",level:3},{value:"Conclusion",id:"conclusionconclusion",level:2}],d={toc:p};function u(e){var t=e.components,o=(0,n.Z)(e,r);return(0,i.kt)("wrapper",(0,a.Z)({},d,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"block-production-in-ethereum-after-the-merge---hackmd"},"Block production in Ethereum after the Merge - HackMD"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"The Ethereum protocol is about to undergo a long-awaited upgrade called \u201cthe Merge\u201d that delivers a move away from the current proof-of-work consensus to a new proof-of-stake consensus.\nThis new consensus mechanism brings some fundamental differences to how blocks are produced and I\u2019d like to explore in detail how we get from transactions individual users make to getting them on-chain.")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"The Ethereum protocol is about to undergo a long-awaited upgrade called \u201cthe Merge\u201d that delivers a move away from the current proof-of-work consensus to a new proof-of-stake consensus. This new consensus mechanism brings some fundamental differences to how blocks are produced and I\u2019d like to explore in detail how we get from transactions individual users make to getting them on-chain."),(0,i.kt)("p",null,"First, we will explore some key differences between a proof-of-work chain and a proof-of-stake chain. With this background at hand, we can look at a detailed round of the consensus protocol and how various features work together to manufacture the canonical chain. Then, we will take a detailed look at the actual block production process following the specifications implemented by client software. Finally, we look at a variety of considerations outside the core \u201chonest\u201d behavior that can affect block production."),(0,i.kt)("p",null,"Before we begin, note that the mechanics of the transaction pool (the \u201cmempool\u201d) are out of scope; we will simply assume block producers have access to this resource."),(0,i.kt)("h2",{id:"a-new-consensus-modela-new-consensus-model"},(0,i.kt)("a",{parentName:"h2",href:"A-new-consensus-model",title:"A-new-consensus-model"}),"A new consensus model"),(0,i.kt)("p",null,"Proof-of-stake represents a different point in the design space of decentralized consensus protocols relative to proof-of-work. Let\u2019s look at some key differences."),(0,i.kt)("h3",{id:"synchronous-protocol-executionsynchronous-protocol-execution"},(0,i.kt)("a",{parentName:"h3",href:"Synchronous-protocol-execution",title:"Synchronous-protocol-execution"}),"Synchronous protocol execution"),(0,i.kt)("p",null,"Ethereum\u2019s proof-of-stake views the consensus protocol as a series of \u201crounds\u201d where each round takes a ",(0,i.kt)("em",{parentName:"p"},"fixed")," amount of time. Each round is called a ",(0,i.kt)("em",{parentName:"p"},"slot")," and on mainnet each slot is 12 seconds. This differs from proof-of-work where the rounds of the consensus protocol have no relation to an external reference time. Rounds in a proof-of-work chain instead proceed by the number of blocks \u2013 the block height."),(0,i.kt)("p",null,"Slots are further aggregated into a larger span of time called an ",(0,i.kt)("em",{parentName:"p"},"epoch"),". There are a certain number of slots per epoch and on mainnet each epoch is 32 slots. The protocol is batched this way to amortize the cost of infrequent, relatively expensive computations across the entire execution."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://storage.googleapis.com/ethereum-hackmd/upload_a024cd654e697b992b5827fb9f628e55.png",alt:null})),(0,i.kt)("p",null,"This diagram shows 6 slots and 2 epochs, implying the ",(0,i.kt)("inlineCode",{parentName:"p"},"SLOTS_PER_EPOCH")," of this chain is 3. Slot and epoch numbers start at 0 and simply increment \u2013 nothing fancy here."),(0,i.kt)("p",null,"We will build on this type of diagram across this article, essentially zooming in at each stage to reveal more detail about the block production process."),(0,i.kt)("h3",{id:"deterministic-public-leader-electiondeterministic-public-leader-election"},(0,i.kt)("a",{parentName:"h3",href:"Deterministic-public-leader-election",title:"Deterministic-public-leader-election"}),"Deterministic, public leader election"),(0,i.kt)("p",null,"At any given time, there is a fixed set of actors on the network who can participate in the consensus protocol. We call these actors \u201cvalidators\u201d or \u201cstakers\u201d relating to the facts that they \u201cvalidate\u201d the chain in order to know what to form consensus on and the reason they have say in this matter is that they have a cryptoeconomic \u201cstake\u201d at risk of forfeiture if they misbehave."),(0,i.kt)("p",null,"A pseudo-random input from the chain is used to shuffle this fixed set and select one validator from the set per slot who is allowed to propose a single block in that slot. No other validator can propose in that slot."),(0,i.kt)("p",null,"This is different from proof-of-work where the next proposer in the chain is not known and in principle can be anyone running the mining protocol."),(0,i.kt)("p",null,"This diagram shows a span of slots across multiple epochs with a proposer shuffling labeled by validator:"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://storage.googleapis.com/ethereum-hackmd/upload_07671ae6275059a08ef80e11f4c5b0a0.png",alt:null})),(0,i.kt)("p",null,"The diagram also calls out the \u201cepoch processing\u201d at the epoch boundaries where batched computation summarizing the previous ",(0,i.kt)("inlineCode",{parentName:"p"},"SLOTS_PER_EPOCH")," slots of activity occurs."),(0,i.kt)("p",null,"One output of epoch processing is the proposer shuffling for the next epoch. This means the proposer in the first slot of an epoch has very little lookahead on their assignment, whereas the last proposer in an epoch has essentially ",(0,i.kt)("inlineCode",{parentName:"p"},"SLOTS_PER_EPOCH - 1")," lookahead."),(0,i.kt)("p",null,"Note that once the chain has been processed through the epoch processing for the previous epoch (e.g ",(0,i.kt)("inlineCode",{parentName:"p"},"epoch processing E - 1")," in the diagram for epoch ",(0,i.kt)("inlineCode",{parentName:"p"},"E"),") then the proposer shuffling for that epoch is fixed and will not change. This stability reduces the space of valid blocks and helps nodes validate the messages they do receive on the network."),(0,i.kt)("h3",{id:"fork-choice-driven-by-validator-setfork-choice-driven-by-validator-set"},(0,i.kt)("a",{parentName:"h3",href:"Fork-choice-driven-by-validator-set",title:"Fork-choice-driven-by-validator-set"}),"Fork choice driven by validator set"),(0,i.kt)("p",null,"A \u201cfork choice\u201d rule is an algorithm for selecting a unique chain from the set of all blocks a consensus client may have locally. Proposers are free to build on top of any block in the chain which means a \u201cfork\u201d in the chain \u2013 multiple blocks with the same parent block \u2013 can occur. In proof-of-work, a common fork choice rule is \u201cselect the chain with the highest total difficulty\u201d. The difficulty refers to the amount of \u201cwork\u201d done to \u201cseal\u201d a given block and a proof-of-work client can simply sum up all the difficulties to get a \u201ctotal difficulty\u201d. Favoring a chain with more work than another suggests a majority of the hashpower views that chain as more \u201ccanonical\u201d than another and by all making the same inference we identify a unique chain."),(0,i.kt)("p",null,"In proof-of-stake, we lose this \u201cdifficulty\u201d metric and instead rely on the stake \u201cweight\u201d of the validators. The algorithm currently used in Ethereum is called ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/fork-choice.md"},(0,i.kt)("inlineCode",{parentName:"a"},"LMD-GHOST"))," and it leverages the messages validator use to come to consensus."),(0,i.kt)("p",null,"Each of these messages, called an ",(0,i.kt)("em",{parentName:"p"},"attestation"),", carries the validator\u2019s current view of the chain and by tallying the amount of stake attesting to a given chain we can infer what the majority of the consensus set thinks is the \u201ccanonical\u201d chain, just like in proof-of-work."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://storage.googleapis.com/ethereum-hackmd/upload_7726e18f64fbdc34c18b541cb59cfc44.png",alt:null})),(0,i.kt)("p",null,"source: ",(0,i.kt)("a",{parentName:"p",href:"https://vitalik.ca/general/2018/12/05/cbc_casper.html"},"https://vitalik.ca/general/2018/12/05/cbc","_","casper.html")),(0,i.kt)("p",null,"This diagram illustrates the fork choice. Each block is marked with its \u201cstake weight\u201d, i.e. a normalized weight indiciating how much of the active stake has attested to a given chain. At each fork, the algorithm simply picks the direct child with the most weight. For example, at the fork with two children the fork choice algorithm would select the chain with weight 3 over the chain with weight 2. Given a tie breaking rule (e.g. pick block with lowest hash), we can then identify a unique head from the set of three blocks in the lower group."),(0,i.kt)("h2",{id:"a-round-of-the-consensus-protocola-round-of-the-consensus-protocol"},(0,i.kt)("a",{parentName:"h2",href:"A-round-of-the-consensus-protocol",title:"A-round-of-the-consensus-protocol"}),"A round of the consensus protocol"),(0,i.kt)("p",null,"We can see how block production fits into the protocol by examining the activity of a single slot."),(0,i.kt)("p",null,"We know that a given validator has the opportunity to propose a block in a given slot and the exact block they produce is influenced by the current state of the chain, as given by the fork choice. The exact context for a proposal is influenced by events that each have strict synchrony assumptions so we can include them on our timing diagram and then go into greater detail below."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://storage.googleapis.com/ethereum-hackmd/upload_38dd15c7a8214b7e096a9bd6a0ce2cc2.png",alt:null})),(0,i.kt)("p",null,"This diagram shows a span of three slots, with the middle slot ",(0,i.kt)("inlineCode",{parentName:"p"},"S")," of primary focus. We see that any given slot is divided into a number of \u201csubslots\u201d that dictate when a validator should peform some duty. This subdivision helps honest validators coordinate their behavior and allow for plenty of time for message dissemination throughout the peer-to-peer network."),(0,i.kt)("p",null,"Note that there are additional duties a validator should perform in the full consensus protocol but are out of scope for this document."),(0,i.kt)("h3",{id:"evaluating-fork-choiceevaluating-fork-choice"},(0,i.kt)("a",{parentName:"h3",href:"Evaluating-fork-choice",title:"Evaluating-fork-choice"}),"Evaluating fork choice"),(0,i.kt)("p",null,"As soon as the local clock moves to the next slot, consensus nodes should run the fork choice to determine the latest state of the chain. In the default case this will simply recognize the block in the prior slot as the head of the chain. In a more extreme case, attestations from the prior slot could induce a reorg to another branch of the block tree. The head of the chain determines key inputs to the block production process as we will see later."),(0,i.kt)("h3",{id:"block-productionblock-production"},(0,i.kt)("a",{parentName:"h3",href:"Block-production",title:"Block-production"}),"Block production"),(0,i.kt)("p",null,"The proposer for slot ",(0,i.kt)("inlineCode",{parentName:"p"},"S")," can produce a single block for this slot. At a high-level, block production involves assembling some consensus-level information and some execution-level information and constructing a block that respects the state transition function of the protocol. Some of these inputs are deterministic based on the protocol state and the validator\u2019s identity. Some of the inputs are gathered from public pools like the attestation pool or the transaction mempool. The operations gathered from the public pools are not synchronized in any way across nodes (this is why we have a blockchain the first place!) so the exact data that goes into a block depends on the proposer\u2019s local view."),(0,i.kt)("h3",{id:"broadcast-blockbroadcast-block"},(0,i.kt)("a",{parentName:"h3",href:"Broadcast-block",title:"Broadcast-block"}),"Broadcast block"),(0,i.kt)("p",null,"The assembled block is broadcast to the peers of the proposer over a gossip network. The gossip dissemination ensures that messages quickly reach all peers on the network."),(0,i.kt)("h3",{id:"broadcast-attestationbroadcast-attestation"},(0,i.kt)("a",{parentName:"h3",href:"Broadcast-attestation",title:"Broadcast-attestation"}),"Broadcast attestation"),(0,i.kt)("p",null,"Just like we have a \u201cshuffling\u201d of proposers, all active validators are employed in a separate shuffling process each epoch and assigned to groups called \u201ccommittees\u201d. To illustrate, think something like chunks of 128 validators out of a set of 262,144 active validators implying 64 committees pseudo-randomly assigned to a given slot. For this set of parameters, 8,192 validators need to attest in each slot."),(0,i.kt)("p",null,"Each active validator ends up asssigned to ",(0,i.kt)("em",{parentName:"p"},"some")," slot each epoch via the committee assignemnt where they are expected to make an ",(0,i.kt)("em",{parentName:"p"},"attestation"),", a claim about their local view of the chain that is broadcast to consensus nodes in this step. Weights in the ",(0,i.kt)("inlineCode",{parentName:"p"},"LMD-GHOST")," algorithm described above are derived from these attestations so this step directly influences the fork choice."),(0,i.kt)("p",null,"In the normal, honest execution, a validator who is called to attest in slot ",(0,i.kt)("inlineCode",{parentName:"p"},"S")," would receive the block just broadcast by the proposer, validate it with respect to the protocol rules, and then assemble their own attestation including a reference to the block."),(0,i.kt)("p",null,"Honest nodes will have ",(0,i.kt)("inlineCode",{parentName:"p"},"1/3 * SECONDS_PER_SLOT")," from the start of the slot to either receive the block or decide there was no block produced and attest to an \u201cempty\u201d or \u201cskip\u201d slot. Once this time has elapsed, attesters should broadcast their attestation reflecting their local view of the chain."),(0,i.kt)("p",null,"This \u201crace\u201d between the proposer and the attesters will be important later when we talk about incentives proposers have around timing the release of their own block and the impact this has on block production."),(0,i.kt)("h3",{id:"broadcast-aggregated-attestationbroadcast-aggregated-attestation"},(0,i.kt)("a",{parentName:"h3",href:"Broadcast-aggregated-attestation",title:"Broadcast-aggregated-attestation"}),"Broadcast aggregated attestation"),(0,i.kt)("p",null,"A key design goal of Ethereum\u2019s consensus is to scale to a large, diverse validator set across many logically different entities to maximize decentralization. Doing so makes it substantially harder to attack the protocol."),(0,i.kt)("p",null,"The proof-of-stake protocol employs a hierarchical network design in order to deal with the large message load induced by the large validator set. This design is realized via \u201csubnets\u201d of the broader gossip network where only a fraction of the entire attester set publishes their individual attestations. This division is a scaling technique as only a subset of all nodes on the network need to deal with the full load of the protocol. If there is an \u201caggregation factor\u201d of ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," (e.g. 64 on mainnet), then the validator set can be ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," times bigger given the same set of computational resources contributed by that set."),(0,i.kt)("p",null,"However, block producers still need to get the full message set and the bridge from the subnets to the global attestation channel with all messages is established by an \u201caggregator\u201d role that exists at the network level. An attestation aggregator is pseudo-randomly selected from the attesters in a given committee and their job is to listen to the appropriate subnet and aggregate attestations from individual committee members into a single attestation. (There is ",(0,i.kt)("a",{parentName:"p",href:"https://hackmd.io/@benjaminion/bls12-381"},"some cool cryptography")," that makes this aggregation possible, even if relatively expensive.)"),(0,i.kt)("p",null,"This aggregate attestation is what is forwarded to ",(0,i.kt)("em",{parentName:"p"},"all")," validators, including the proposer for the next slot who can then include this contribution on-chain. Honest aggregators are expected to do this at ",(0,i.kt)("inlineCode",{parentName:"p"},"2/3 * SECONDS_PER_SLOT")," from the start of the slot."),(0,i.kt)("p",null,"It is worth repeating: even if a node is not proposing (or even attesting) in the next slot, the attestations collected from the network at this stage do influence each node\u2019s fork choice. In extreme cases, a single attestation received could cause a reorg of the chain."),(0,i.kt)("h3",{id:"repeatrepeat"},(0,i.kt)("a",{parentName:"h3",href:"Repeat",title:"Repeat"}),"Repeat"),(0,i.kt)("p",null,"The next proposer for slot ",(0,i.kt)("inlineCode",{parentName:"p"},"S + 1")," should be ready and waiting for the start of ",(0,i.kt)("inlineCode",{parentName:"p"},"S + 1")," to repeat the cycle by running the fork choice given their local view (incorporating any new attestation information), assembling a full block and broadcasting this block to advance the state of chain."),(0,i.kt)("p",null,"Time is a flat circle."),(0,i.kt)("h2",{id:"architecture-of-the-mergearchitecture-of-the-merge"},(0,i.kt)("a",{parentName:"h2",href:"Architecture-of-the-Merge",title:"Architecture-of-the-Merge"}),"Architecture of the Merge"),(0,i.kt)("p",null,"To understand the various steps of block production we need a clear idea of the software components found in Ethereum implementations. This section describes the most common patterns found in clients today."),(0,i.kt)("h3",{id:"all-good-things-have-layersall-good-things-have-layers"},(0,i.kt)("a",{parentName:"h3",href:"All-good-things-have-layers",title:"All-good-things-have-layers"}),"All good things have layers"),(0,i.kt)("p",null,"The move to proof-of-stake transitions Ethereum from a single, monolithic chain to one that has multiple, specialized layers. The main layers to be aware of are the ",(0,i.kt)("em",{parentName:"p"},"consensus layer (CL)")," and the ",(0,i.kt)("em",{parentName:"p"},"execution layer (EL)"),". There are a set of ",(0,i.kt)("em",{parentName:"p"},"consensus clients")," and ",(0,i.kt)("em",{parentName:"p"},"execution clients")," that implement the functionality of each layer. Taken together, they implement the Ethereum protocol."),(0,i.kt)("p",null,"These clients communicate over the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/ethereum/execution-apis/blob/main/src/engine/specification.md"},"Engine API"),". This architecture lets each client specialize in their respective domain \u2013 CL clients handle the proof-of-stake protocol while outsourcing execution concerns to the EL clients."),(0,i.kt)("p",null,"Another important element is the ",(0,i.kt)("em",{parentName:"p"},"validator client (VC)"),". This piece of software separates the high-security concerns of validating the chain from the relatively lower-security conern of just following the consensus as a full node. There is a ",(0,i.kt)("a",{parentName:"p",href:"https://ethereum.github.io/beacon-APIs"},"Beacon API")," that VCs commonly use to talk to a local CL client."),(0,i.kt)("p",null,"As a diagram:"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://storage.googleapis.com/ethereum-hackmd/upload_b13075221c0253487e8702b134686286.png",alt:null})),(0,i.kt)("p",null,"One subtlety worth noticing is that each layer peers with other clients of the same type across the public internet but communication across layers only happens locally."),(0,i.kt)("h3",{id:"how-do-the-layers-communicatehow-do-the-layers-communicate"},(0,i.kt)("a",{parentName:"h3",href:"How-do-the-layers-communicate",title:"How-do-the-layers-communicate"}),"How do the layers communicate?"),(0,i.kt)("p",null,"All of the communication described so far is between a consensus client and an attached validator client communicating over the Beacon API. The consensus clients in this network form the gossip \u201cmesh\u201d so that validator clients are not directly connected to the public internet."),(0,i.kt)("p",null,"After the Merge, a consensus client must have an attached execution client as post-Merge blocks will have execution data in them that only the execution client can verify. A consensus client cannot include a block into the fork choice computation without having the full verification performed. Moreover, an execution client is not passing around blocks from the consensus layer to respect the separation of concerns. Consensus layer blocks are only gossiped at that layer and transactions are only gossiped at the execution layer."),(0,i.kt)("p",null,"The Engine API facilitates this communication where there are high-level flows for the consensus layer to learn \u201cis this execution payload valid?\u201d and for the execution layer to learn \u201cok, the fork choice has updated to this head\u201d. These flows correspond to two Engine API methods: ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/ethereum/execution-apis/blob/main/src/engine/specification.md#engine_newpayloadv1"},(0,i.kt)("inlineCode",{parentName:"a"},"engine_newPayload"))," and ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/ethereum/execution-apis/blob/main/src/engine/specification.md#engine_forkchoiceupdatedv1"},(0,i.kt)("inlineCode",{parentName:"a"},"engine_forkchoiceUpdated")),"."),(0,i.kt)("h3",{id:"better-togetherbetter-together"},(0,i.kt)("a",{parentName:"h3",href:"Better-together",title:"Better-together"}),"Better together"),(0,i.kt)("p",null,"Let\u2019s examine how the consensus client and execution client can work together to verify a full post-Merge block."),(0,i.kt)("p",null,"Upon receiving a block, a consenus client can validate the consensus data but must defer to the local execution client to determine the validity of the execution payload. The execution client is notified via ",(0,i.kt)("inlineCode",{parentName:"p"},"engine_newPayload")," which responds with the validation status."),(0,i.kt)("p",null,"If the full block is valid, then the consensus client can add it to its block tree where it can become a candidate for the new head of the chain. In the default case where the canonical chain is extended by this incoming block, the fork choice yields this block as the new head and issues a separate call using the ",(0,i.kt)("inlineCode",{parentName:"p"},"engine_forkchoiceUpdated")," method to inform the execution client of this outcome."),(0,i.kt)("p",null,"This new verification flow extends our timing diagram:"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://storage.googleapis.com/ethereum-hackmd/upload_5d3c1122835d70c05e7b8839249fdda9.png",alt:null})),(0,i.kt)("p",null,"The fork choice in slot ",(0,i.kt)("inlineCode",{parentName:"p"},"S")," reflects any blocks and attestations collected in slot ",(0,i.kt)("inlineCode",{parentName:"p"},"S - 1")," and the result of the fork choice is sent to the execution client in the call to ",(0,i.kt)("inlineCode",{parentName:"p"},"engine_forkchoiceUpdated"),". This diagram includes a propagation latency ",(0,i.kt)("inlineCode",{parentName:"p"},"d")," which represents the time it takes for the block produced by the proposer of slot ",(0,i.kt)("inlineCode",{parentName:"p"},"S")," to travel around the gossip network to a different node who would then verify the block according to the marker after the delay. This step is where the consensus node, after validating the consensus data in the block, needs to make a call to notify the execution node about the new payload with ",(0,i.kt)("inlineCode",{parentName:"p"},"engine_newPayload"),". If the payload is valid, then the consensus node will include the block into its block tree as a candidate for the head of the chain during the next evaluation of the fork choice."),(0,i.kt)("h2",{id:"block-production-in-detailblock-production-in-detail"},(0,i.kt)("a",{parentName:"h2",href:"Block-production-in-detail",title:"Block-production-in-detail"}),"Block production in detail"),(0,i.kt)("p",null,"We will now examine block production in detail and see how a proposer uses the Engine API to orchestrate block production."),(0,i.kt)("p",null,"To begin the process, we enter a slot ",(0,i.kt)("inlineCode",{parentName:"p"},"S")," in which a validator has learned of a proposal assignment. The validator client managing this validator has learned of the assigned duty by calling the ",(0,i.kt)("a",{parentName:"p",href:"https://ethereum.github.io/beacon-APIs/#/Validator/getProposerDuties"},(0,i.kt)("inlineCode",{parentName:"a"},"getProposerDuties")," method of the Beacon API")," ahead of time."),(0,i.kt)("p",null,"For reasons that will become clear later, the validator client is responsible for issuing two messages. The first uses ",(0,i.kt)("a",{parentName:"p",href:"https://ethereum.github.io/beacon-APIs/#/Validator/prepareBeaconProposer"},(0,i.kt)("inlineCode",{parentName:"a"},"prepareBeaconProposer")," method of the Beacon API")," to send data that is validator-dependent but is required when building an execution payload. The second uses the ",(0,i.kt)("a",{parentName:"p",href:"https://ethereum.github.io/beacon-APIs/#/Validator/produceBlockV2"},(0,i.kt)("inlineCode",{parentName:"a"},"produceBlock")," method of the Beacon API")," to signal to the consensus client that it should start building a valid block."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"prepareBeaconProposer")," call includes the ",(0,i.kt)("inlineCode",{parentName:"p"},"fee_recipient")," the validator chooses for this execution payload. This field refers to the execution layer address the validator wants any EIP-1559 tips to go to. These tips include priority fees and any MEV in the block so validators will want to select an EL address they control to maximize revenue."),(0,i.kt)("h3",{id:"assembling-the-consensus-envelopeassembling-the-consensus-envelope"},(0,i.kt)("a",{parentName:"h3",href:"Assembling-the-consensus-envelope",title:"Assembling-the-consensus-envelope"}),"Assembling the consensus envelope"),(0,i.kt)("p",null,"The consensus client begins the build process upon receipt of the ",(0,i.kt)("inlineCode",{parentName:"p"},"produceBlock")," call. This call can race with the consensus client\u2019s execution of the fork choice so servicing the ",(0,i.kt)("inlineCode",{parentName:"p"},"produceBlock")," request should block until the fork choice in slot ",(0,i.kt)("inlineCode",{parentName:"p"},"S")," has been determined."),(0,i.kt)("p",null,"This part of the build process will fill in a ",(0,i.kt)("inlineCode",{parentName:"p"},"BeaconBlock")," up to the ",(0,i.kt)("inlineCode",{parentName:"p"},"execution_payload")," based on the current state of the consensus client."),(0,i.kt)("p",null,"Click here to see definitions of block data"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Beacon block header",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#beaconblock"},"https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#beaconblock")))),(0,i.kt)("li",{parentName:"ul"},"Beacon block body",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#beaconblockbody"},"https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#beaconblockbody")))),(0,i.kt)("li",{parentName:"ul"},"With extensions for ",(0,i.kt)("inlineCode",{parentName:"li"},"altair")," fork",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/beacon-chain.md#beaconblockbody"},"https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/beacon-chain.md#beaconblockbody")))),(0,i.kt)("li",{parentName:"ul"},"With extensions for ",(0,i.kt)("inlineCode",{parentName:"li"},"bellatrix")," fork",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/ethereum/consensus-specs/blob/dev/specs/bellatrix/beacon-chain.md#beaconblockbody"},"https://github.com/ethereum/consensus-specs/blob/dev/specs/bellatrix/beacon-chain.md#beaconblockbody"))))),(0,i.kt)("h4",{id:"validator-inputsvalidator-inputs"},(0,i.kt)("a",{parentName:"h4",href:"Validator-inputs",title:"Validator-inputs"}),"Validator inputs"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"produceBlock")," call requires the following input from the validator:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"slot")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"randao_reveal")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"graffiti"))),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"slot")," identifies which the block proposal corresponding to this request. The ",(0,i.kt)("inlineCode",{parentName:"p"},"randao_reveal")," is this validator\u2019s contribution to the on-chain randomness. This data is verifiably linked to the validator\u2019s private signing key and is a pure function of the current epoch. The ",(0,i.kt)("inlineCode",{parentName:"p"},"graffiti")," is 32 bytes of the validator\u2019s choosing to be included in the proposal. This field is optional and if not provided a consensus client can choose whatever they see fit."),(0,i.kt)("h4",{id:"deterministic-cl-inputsdeterministic-cl-inputs"},(0,i.kt)("a",{parentName:"h4",href:"Deterministic-CL-inputs",title:"Deterministic-CL-inputs"}),"Deterministic CL inputs"),(0,i.kt)("p",null,"Based on the request\u2019s data and the beacon state for the requested ",(0,i.kt)("inlineCode",{parentName:"p"},"slot"),", the beacon block will have the following additonal data fixed:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"proposer_index")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"parent_root"))),(0,i.kt)("p",null,"The following inputs are also deterministic in the sense that they are derived from the corresponding execution state to the beacon state in ",(0,i.kt)("inlineCode",{parentName:"p"},"slot"),". An execution client could then produce:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"eth1_data")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"deposits"))),(0,i.kt)("p",null,"These fields currently faciliate one-way deposits from the EL into the CL."),(0,i.kt)("h4",{id:"nondeterministic-cl-inputsnondeterministic-cl-inputs"},(0,i.kt)("a",{parentName:"h4",href:"Nondeterministic-CL-inputs",title:"Nondeterministic-CL-inputs"}),"Nondeterministic CL inputs"),(0,i.kt)("p",null,"The remainder of the CL operations are gathered from local mempools containing messages that have been observed via gossip. These fields are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"proposer_slashings")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"attester_slashings")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"attestations")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"voluntary_exits")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"sync_aggregate"))),(0,i.kt)("p",null,"These inputs support execution of the proof-of-stake consensus, exits from the validator set and efficient light clients of the consensus chain. There are conditions on assembling valid inputs here but this is out of scope for this document which focuses on the end-to-end orchestration of block production after the Merge with an emphasis on getting user transactions on-chain."),(0,i.kt)("p",null,"Click here to learn more about the details of building a consensus block"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/validator.md#block-proposal"},"https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/validator.md#block-proposal")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/validator.md#block-proposal"},"https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/validator.md#block-proposal")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://lighthouse-blog.sigmaprime.io/attestation-packing.html"},"https://lighthouse-blog.sigmaprime.io/attestation-packing.html")),(0,i.kt)("li",{parentName:"ul"},"Optimizing Eth2 by Michael Sproul (Devcon5): ",(0,i.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=68s_hdM4fHY"},"https://www.youtube.com/watch?v=68s","_","hdM4fHY"))),(0,i.kt)("h3",{id:"orchestrating-the-execution-payload-buildorchestrating-the-execution-payload-build"},(0,i.kt)("a",{parentName:"h3",href:"Orchestrating-the-execution-payload-build",title:"Orchestrating-the-execution-payload-build"}),"Orchestrating the execution payload build"),(0,i.kt)("p",null,"After performing the previous steps, a consensus client will have a ",(0,i.kt)("inlineCode",{parentName:"p"},"BeaconBlock")," without an ",(0,i.kt)("inlineCode",{parentName:"p"},"execution_payload"),". It is the responsibility of the execution client to build this payload. The communication flow that supports this build process is structured across two messages of the Engine API. Having two messages allows for an asynchronous build process that allows the execution client a maxium amount of time to build the most valuable payload it can to maximize a proposer\u2019s revenue."),(0,i.kt)("p",null,"To dispatch the build, the consensus client uses the ",(0,i.kt)("inlineCode",{parentName:"p"},"engine_forkchoiceUpdated")," method we have alread seen. The semantics of this method allow for an optional ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/ethereum/execution-apis/blob/main/src/engine/specification.md#payloadattributesv1"},(0,i.kt)("inlineCode",{parentName:"a"},"PayloadAttributes"))," that contain the relevant consensus information required to build a valid execution payload."),(0,i.kt)("p",null,"We already saw ",(0,i.kt)("inlineCode",{parentName:"p"},"engine_forkchoiceUpdated")," in the normal operation of advancing the head of the canonical chain. The idea here is that a consensus client can \u201cpiggyback\u201d onto this message when it knows it has a proposer expecting a payload. The consensus client learns it has a proposer in a given slot by tracking ",(0,i.kt)("inlineCode",{parentName:"p"},"prepareBeaconProposer")," messages we saw previously."),(0,i.kt)("p",null,"Reusing the ",(0,i.kt)("inlineCode",{parentName:"p"},"engine_forkchoiceUpdated")," method helps performance by avoiding a separate round trip of communication to signal a payload build. The reuse also avoids race conditions between what would otherwise be multiple calls in parallel. This method call returns an opaque ",(0,i.kt)("inlineCode",{parentName:"p"},"PayloadId")," that uniquely refers to the payload the execution client has started building in response to the ",(0,i.kt)("inlineCode",{parentName:"p"},"PayloadAttributes"),"."),(0,i.kt)("p",null,"To retrieve the payload, the consensus client can use this ",(0,i.kt)("inlineCode",{parentName:"p"},"PayloadId")," along with the second message involved in the build process: the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/ethereum/execution-apis/blob/main/src/engine/specification.md#engine_getpayloadv1"},(0,i.kt)("inlineCode",{parentName:"a"},"engine_getPayload")," method of the Engine API"),"."),(0,i.kt)("h3",{id:"assembling-the-execution-payloadassembling-the-execution-payload"},(0,i.kt)("a",{parentName:"h3",href:"Assembling-the-execution-payload",title:"Assembling-the-execution-payload"}),"Assembling the execution payload"),(0,i.kt)("p",null,"Let\u2019s now examine the mechanics of the execution client to understand how an execution payload is made."),(0,i.kt)("h4",{id:"validator-inputs1validator-inputs"},(0,i.kt)("a",{parentName:"h4",href:"Validator-inputs1",title:"Validator-inputs1"}),"Validator inputs"),(0,i.kt)("p",null,"The validator can provide direct inputs for the execution payload:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fee_recipient")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"extra_data")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"gas_limit"))),(0,i.kt)("p",null,"We already saw that the ",(0,i.kt)("inlineCode",{parentName:"p"},"fee_recipient")," comes from the ",(0,i.kt)("inlineCode",{parentName:"p"},"PayloadAttributes")," sent from the consensus client in the ",(0,i.kt)("inlineCode",{parentName:"p"},"engine_forkchoiceUpdated")," message (and that the consensus client got this information from the ",(0,i.kt)("inlineCode",{parentName:"p"},"prepareBeaconProposer")," message). It is referred to as a ",(0,i.kt)("inlineCode",{parentName:"p"},"suggestedFeeRecipient")," in the Engine API to reflect the fact that the execution client may use a different fee recipient than the one provided here. This flexibility supports diversity in payload builder designs."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"extra_data")," is similar to the beacon block\u2019s ",(0,i.kt)("inlineCode",{parentName:"p"},"graffiti")," and is between 0 and 32 bytes of the validator\u2019s choosing. Today\u2019s client implementations make it a bit tricky to configure ",(0,i.kt)("inlineCode",{parentName:"p"},"extra_data")," per validator but there is ongoing work to extend the Engine API to support this use case."),(0,i.kt)("p",null,"A validator should be able to choose a ",(0,i.kt)("inlineCode",{parentName:"p"},"gas_limit")," the execution client should respect when deciding which transactions to put into a block. The ",(0,i.kt)("inlineCode",{parentName:"p"},"gas_limit")," is something that traditionally has been under control of the miners and it makes sense to move this responsibility to validators with the Merge. The execution client has protocol rules to follow around how much the ",(0,i.kt)("inlineCode",{parentName:"p"},"gas_limit")," can change from block to block, but to the extent possible it should move the proposal\u2019s ",(0,i.kt)("inlineCode",{parentName:"p"},"gas_limit")," to be in line with this proposer\u2019s preference. There is not a direct way to set the ",(0,i.kt)("inlineCode",{parentName:"p"},"gas_limit")," per validator but there is ongoing work to extend the Engine API for this use case."),(0,i.kt)("h4",{id:"deterministic-cl-inputs1deterministic-cl-inputs"},(0,i.kt)("a",{parentName:"h4",href:"Deterministic-CL-inputs1",title:"Deterministic-CL-inputs1"}),"Deterministic CL inputs"),(0,i.kt)("p",null,"There are only a few inputs the EL requires from the CL to build a valid payload:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"timestamp")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"prev_randao")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"parent_hash"))),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"timestamp")," refers to a \u201clegacy\u201d field of the proof-of-work chain where a miner could include some timestamp to serve as an oracle of time off-chain. With the Merge, this field simply becomes a pure function of the current ",(0,i.kt)("inlineCode",{parentName:"p"},"slot"),", i.e. the wall clock time corresponding to the start of ",(0,i.kt)("inlineCode",{parentName:"p"},"slot"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"prev_randao")," is the ",(0,i.kt)("inlineCode",{parentName:"p"},"randao_mix")," from the beacon state as of the previous slot ",(0,i.kt)("inlineCode",{parentName:"p"},"S - 1")," and provides a source of weak randomness on-chain."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"parent_hash")," is exactly the ",(0,i.kt)("inlineCode",{parentName:"p"},"headBlockHash")," from the ",(0,i.kt)("inlineCode",{parentName:"p"},"engine_forkchoiceUpdated")," call that triggers the build process."),(0,i.kt)("h4",{id:"determinstic-el-inputsdeterminstic-el-inputs"},(0,i.kt)("a",{parentName:"h4",href:"Determinstic-EL-inputs",title:"Determinstic-EL-inputs"}),"Determinstic EL inputs"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"parent_hash")," fixes a particular execution state to build on top of. Fixing this state also fixes the following data:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"block_number")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"base_fee_per_gas"))),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"block_number")," is simply the increment of the parent\u2019s block number. And EIP-1559 specifies a deterministic formula for deciding a block\u2019s ",(0,i.kt)("inlineCode",{parentName:"p"},"base_fee_per_gas")," given the parent\u2019s ",(0,i.kt)("inlineCode",{parentName:"p"},"base_fee_per_gas")," and the parent\u2019s ",(0,i.kt)("inlineCode",{parentName:"p"},"gas_used"),"."),(0,i.kt)("h4",{id:"nondeterministic-el-inputsnondeterministic-el-inputs"},(0,i.kt)("a",{parentName:"h4",href:"Nondeterministic-EL-inputs",title:"Nondeterministic-EL-inputs"}),"Nondeterministic EL inputs"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"transactions"))),(0,i.kt)("p",null,"The prior inputs fix the execution context and now it is the job of the payload builder to select the ",(0,i.kt)("inlineCode",{parentName:"p"},"transactions")," they wish to put into the block. The builder has freedom to include (or not!) any valid transactions they have at hand as long as they consume no more gas than the delcared ",(0,i.kt)("inlineCode",{parentName:"p"},"gas_limit"),". Selecting a transaction set can be a very involved process and doing so efficiently to maximize revenue merits its own article (incoming!). For the purposes of this article, we see how a transaction we make ends up actually getting into a block: via inclusion in this list by the builder of this payload."),(0,i.kt)("h3",{id:"sealing-the-complete-blocksealing-the-complete-block"},(0,i.kt)("a",{parentName:"h3",href:"Sealing-the-complete-block",title:"Sealing-the-complete-block"}),"Sealing the complete block"),(0,i.kt)("p",null,"Given all of the above inputs, an execution client can compute the remaining fields of the execution payload after applying the selected transactions against the head execution state."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"state_root")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"receipts_root")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"logs_bloom")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"gas_used")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"block_hash"))),(0,i.kt)("p",null,"These fields all commit to particular outputs of the EVM after applying the state transition implicit in the sequence of ",(0,i.kt)("inlineCode",{parentName:"p"},"transactions"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},"block_hash")," itself functions as a succinct committment to everything in this execution block."),(0,i.kt)("p",null,"Having built a valid execution payload, the execution client waits for an ",(0,i.kt)("inlineCode",{parentName:"p"},"engine_getPayload")," message with the ",(0,i.kt)("inlineCode",{parentName:"p"},"PayloadId")," associated with this build and returns the full payload to the consensus client."),(0,i.kt)("p",null,"The consensus client can finally(!) fill the remainder of the beacon block and compute the ",(0,i.kt)("inlineCode",{parentName:"p"},"state_root")," of the beacon state after applying the complete proposal."),(0,i.kt)("p",null,"With a complete beacon block, the consensus client can answer the ",(0,i.kt)("inlineCode",{parentName:"p"},"produceBlock")," request. The validator client at this point signs the block as a \u201cseal\u201d, conferring the cryptoecononimc weight of the validator\u2019s stake onto the block."),(0,i.kt)("p",null,"To complete the block production process, the validator client returns the signed beacon block via the ",(0,i.kt)("a",{parentName:"p",href:"https://ethereum.github.io/beacon-APIs/#/Beacon/publishBlock"},(0,i.kt)("inlineCode",{parentName:"a"},"publishBlock")," method of the Beacon API")," where the consensus client can broadcast the signed block via gossip to its peers."),(0,i.kt)("h2",{id:"optimizations-for-block-productionoptimizations-for-block-production"},(0,i.kt)("a",{parentName:"h2",href:"Optimizations-for-block-production",title:"Optimizations-for-block-production"}),"Optimizations for block production"),(0,i.kt)("p",null,"We have seen the full lifecycle of block production beginning in the proposer\u2019s slot and tracing the data flow across layers of the protocol stack until a signed block is broadcast. Assuming we want to maximize the value a proposer collects from a given block and knowing that in general more time to build a payload will yield a more valuable payload, it is natural to ask how early we can begin the execution build process."),(0,i.kt)("p",null,"To answer this question, we can look at the execution inputs just identified:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fee_recipient")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"extra_data")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"gas_limit")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"timestamp")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"prev_randao")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"parent_hash"))),(0,i.kt)("p",null,"Let\u2019s assume we have the ",(0,i.kt)("inlineCode",{parentName:"p"},"extra_data")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"gas_limit")," fields ahead of time. They will generally be set upon boot of the execution node and not change throughout the node\u2019s lifetime. The ",(0,i.kt)("inlineCode",{parentName:"p"},"fee_recipient")," came from the ",(0,i.kt)("inlineCode",{parentName:"p"},"prepareBeaconProser")," message which we saw can be sent separately to the rest of the orchestration messages. And in fact, the spec currently dictates 3 epochs of persistence for this message so it can be sent well in advance. Handling the ",(0,i.kt)("inlineCode",{parentName:"p"},"fee_recipient")," this way takes it off the \u201ccritical path\u201d of block production so helps performance overall."),(0,i.kt)("p",null,"The remaining inputs are all determined by the beacon state that serves as input to the state transition of the proposal\u2019s slot. This state determines the proposer shuffling which gives us the target ",(0,i.kt)("inlineCode",{parentName:"p"},"slot")," so that we can compute the ",(0,i.kt)("inlineCode",{parentName:"p"},"timetamp")," and select the ",(0,i.kt)("inlineCode",{parentName:"p"},"prev_randao"),". This state also references the proposal\u2019s ",(0,i.kt)("inlineCode",{parentName:"p"},"parent_hash"),"."),(0,i.kt)("p",null,"Our question now becomes: how early do we know this input beacon state for a proposal in slot ",(0,i.kt)("inlineCode",{parentName:"p"},"S"),"? As soon as we can compute the head of slot ",(0,i.kt)("inlineCode",{parentName:"p"},"S - 1"),". And this suggests a proposer can optimistically start a build process in the slot prior to its target slot."),(0,i.kt)("p",null,"Assuming a proposer can accept the re-org risk of about 1 slot (which is quite low), then a consensus client can be configured to attach the appropriate ",(0,i.kt)("inlineCode",{parentName:"p"},"PayloadAttributes")," to an ",(0,i.kt)("inlineCode",{parentName:"p"},"engine_forkchoiceUpdated")," call as soon as the block in slot ",(0,i.kt)("inlineCode",{parentName:"p"},"S - 1")," has been processed, rather than waiting for the next slot. And in fact, this is how the execution payload build process is implemented in clients today."),(0,i.kt)("p",null,"Putting everything together, we get a timing diagram that looks like this:"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://storage.googleapis.com/ethereum-hackmd/upload_940583e26ce53d66917444ea3cac60af.png",alt:null})),(0,i.kt)("p",null,"We see that at the cost of an additional ",(0,i.kt)("inlineCode",{parentName:"p"},"engine_forkchoiceUpdated"),", the execution client gets much more time to build a payload rather then essentially doing it inline during the slot of the proposal."),(0,i.kt)("h2",{id:"an-external-builder-networkan-external-builder-network"},(0,i.kt)("a",{parentName:"h2",href:"An-external-builder-network",title:"An-external-builder-network"}),"An external builder network"),(0,i.kt)("p",null,"So far, we have explored block production in the context of a consensus client working with a local execution client as directed by a validator client to build blocks to propose for inclusion into the canonical chain. It turns out that the task of constructing an execution payload is valuable enough to support a set of actors (referred to as \u201cbuilders\u201d) outside of consensus who specialize in crafting the most valuable payloads they can."),(0,i.kt)("p",null,"To avoid centralization pressures that would colocate proposers with these builders (as the outsized returns from sophisticated building would encourage pooling of stake), a second pathway has been specified in the Beacon API that connects any proposer with this \u201cexternal builder\u201d network. This pathway will not be live until the Merge but we can expect any rational validator to take advantage of it."),(0,i.kt)("p",null,"This pathway follows a similar design to the pathway we have looked at so far. Common designs as popularized by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/flashbots/mev-boost/"},"Flashbot\u2019s ",(0,i.kt)("inlineCode",{parentName:"a"},"mev-boost"))," involve another software component that handles communication between the local validator client and the external builder network as a \u201csidecar\u201d."),(0,i.kt)("p",null,"This extends our earlier architecture diagram:"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://storage.googleapis.com/ethereum-hackmd/upload_7b60a30733135ba31003f2e1110c5302.png",alt:null})),(0,i.kt)("h3",{id:"a-second-block-production-pathwaya-second-block-production-pathway"},(0,i.kt)("a",{parentName:"h3",href:"A-second-block-production-pathway",title:"A-second-block-production-pathway"}),"A second block production pathway"),(0,i.kt)("p",null,"Rather than a local ",(0,i.kt)("inlineCode",{parentName:"p"},"prepareBeaconProposer")," message, validators send a ",(0,i.kt)("a",{parentName:"p",href:"https://ethereum.github.io/beacon-APIs/#/Validator/registerValidator"},(0,i.kt)("inlineCode",{parentName:"a"},"registerValidator")," message from the Beacon API")," to upstream their building preferences to this external network. This message is assumed to be sent and propagated throughout the builder network well ahead of the actual proposal slot just like the ",(0,i.kt)("inlineCode",{parentName:"p"},"prepareBeaconProposer")," message. The relevant data in this message for the payload construction process are the ",(0,i.kt)("inlineCode",{parentName:"p"},"fee_recipient")," and the ",(0,i.kt)("inlineCode",{parentName:"p"},"gas_limit")," which function the same way as discussed above."),(0,i.kt)("p",null,"To signal that a validator wishes to use the external builder network in lieu of the local execution client, it calls the ",(0,i.kt)("a",{parentName:"p",href:"https://ethereum.github.io/beacon-APIs/#/Validator/produceBlindedBlock"},(0,i.kt)("inlineCode",{parentName:"a"},"produceBlindedBlock")," method of the Beacon API"),". This method has the same inputs as the ",(0,i.kt)("inlineCode",{parentName:"p"},"produceBlock")," method but instructs the consensus client to produce a \u201cblinded\u201d block. In order to ensure any proposer can participate in this network, the data flow resembles a \u201ccommit-reveal\u201d scheme where the builder network produces payloads in the first step that commit to a given transaction set but do not reveal this set to the proposer. This way a proposer cannot \u201csteal\u201d the output of the builder\u2019s work for themselves. To opt-in to a given built payload, the proposer can respond with a signature that binds them to this committed transaction set (and the rest of the complete block). Once the proposer has released a signature for the block, the payload can be made public and anyone can assemble the corresponding ",(0,i.kt)("inlineCode",{parentName:"p"},"SignedBeaconBlock"),"."),(0,i.kt)("p",null,"The implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"produceBlindedBlock")," works similarly to the local pathway, with the exception of calling out to the external builder network for the execution payload rather than the local execution client. Rather than calling ",(0,i.kt)("inlineCode",{parentName:"p"},"engine_getPayload")," with some local ",(0,i.kt)("inlineCode",{parentName:"p"},"PayloadId"),", the consensus client knows to instead call external builder software that implements the ",(0,i.kt)("a",{parentName:"p",href:"https://ethereum.github.io/builder-specs/"},"Builder API"),", an interface connecting proposers to builders on this network. This API exposes a method ",(0,i.kt)("a",{parentName:"p",href:"https://ethereum.github.io/builder-specs/#/Builder/getHeader"},(0,i.kt)("inlineCode",{parentName:"a"},"getHeader")," from the Builder API")," to fetch the best execution payload header that builders can offer for the given slot. This header is included in the ",(0,i.kt)("inlineCode",{parentName:"p"},"BlindedBeaconBlock")," that the proposer can then sign. Once signed, they can upstream the ",(0,i.kt)("inlineCode",{parentName:"p"},"SignedBlindedBeaconBlock")," to the builder network with the ",(0,i.kt)("a",{parentName:"p",href:"https://ethereum.github.io/beacon-APIs/#/Beacon/publishBlindedBlock"},(0,i.kt)("inlineCode",{parentName:"a"},"publishBlindedBlock")," method of the Beacon API")," which in turn calls the ",(0,i.kt)("a",{parentName:"p",href:"https://ethereum.github.io/builder-specs/#/Builder/submitBlindedBlock"},(0,i.kt)("inlineCode",{parentName:"a"},"submitBlindedBlock")," method of the Builder API"),". Once builders have the blinded block, they are free to release the \u201cunblinded\u201d execution payload so that anyone (including themselves) can assemble the ",(0,i.kt)("inlineCode",{parentName:"p"},"SignedBeaconBlock")," the network is waiting for and broadcast it. This pathway adds an additional roundtrip of communication compared to the local pathway but builders are expected to provide highly available and low (enough) latency services so their blocks are included in the chain. The value-add from specialized building should be enough of an incentive for proposers to use this service, even if it adds a small amount of end-to-end latency to the full block production pipeline."),(0,i.kt)("h2",{id:"further-considerationsfurther-considerations"},(0,i.kt)("a",{parentName:"h2",href:"Further-considerations",title:"Further-considerations"}),"Further considerations"),(0,i.kt)("p",null,"The block production process described so far assumes the optimal case where the next block in the chain simply extends the canonical chain by following the specification. In this honest setting we have continuity in the protocol so implementations have some predictive power to ensure smooth production of blockspace."),(0,i.kt)("p",null,"Block producers should be prepared to handle a variety of conditions outside this honest setting, either via accidental or adversarial behavior, so we will explore some additional points before concluding."),(0,i.kt)("h3",{id:"proposer-lookaheadproposer-lookahead"},(0,i.kt)("a",{parentName:"h3",href:"Proposer-lookahead",title:"Proposer-lookahead"}),"Proposer lookahead"),(0,i.kt)("p",null,"This first point is a subtlety of the consensus protocol itself. There is one \u201cambient\u201d input to the block production process that was not explicitly called out as it fundamentally determines when a validator should propose: the proposer shuffling."),(0,i.kt)("p",null,"This shuffling ",(0,i.kt)("em",{parentName:"p"},"technically")," has no lookahead due to a corner of the consensus protocol design, unlike the other shufflings in the protcol that have at least one epoch (if not much more) lookahead so validators have ample time to prepare."),(0,i.kt)("p",null,"The lookahead on proposer duties is given by using a RANDAO input from a past epoch, just like the attestation duties. The wrinkle appears when we realize that proposers are selected not only via a shuffling driven by RANDAO but also in proportion to their balance. These balances can change when processing the results of an epoch. In the ",(0,i.kt)("em",{parentName:"p"},"worst")," case, enough balances change that the proposer shuffling computed in epoch ",(0,i.kt)("inlineCode",{parentName:"p"},"E - 1")," differs from the proposer shuffling computed in epoch ",(0,i.kt)("inlineCode",{parentName:"p"},"E"),"."),(0,i.kt)("p",null,"The chances of this happening seem relatively low (there is a \u201chysteresis\u201d applied so balances aren\u2019t a source of frequent thrash) and a straightforward analysis of the chain to date would provide empirical data to back up this intution (research incoming!). However, for completeness, a block producer would want to keep track of the likelihood of the shuffling changing and be prepared to quickly update any work they do ahead of time. Regardless of what the shuffling ends up being, it is fixed for the entire epoch so this consideration applies to early-epoch proposers more than late-epoch proposers."),(0,i.kt)("h3",{id:"reorgsreorgs"},(0,i.kt)("a",{parentName:"h3",href:"Reorgs",title:"Reorgs"}),"Reorgs"),(0,i.kt)("p",null,"We saw all parameters of the build process are highly sensitive to the current state of the chain. If a reorg occurs that switches from one head to another in the block tree, there will be a different head state to build upon which means a different set of inputs to the build process. As discussed above, reorgs in Ethereum after the Merge occur in response to the attestation flow a local consensus client sees. The timing of attestation production and processing via the call to the fork choice then become critical junctures where a proposer may need to start building upon a different head of the chain. In the worst case, block production software needs to be tolerant to the situation where it thinks the proposer at slot ",(0,i.kt)("inlineCode",{parentName:"p"},"S")," is one validator but a reorg at the start of slot ",(0,i.kt)("inlineCode",{parentName:"p"},"S")," moves the chain head elsewhere with divergent shufflings."),(0,i.kt)("p",null,"Well-resourced block builders, like those in the external builder network, will likely have blocks built on all possible heads of the chain to anticipate a request across any chain tip. Sophisticated builders could even try to predict the \u201creorg probability\u201d and use this distribution to direct computational resources to one payload over another."),(0,i.kt)("p",null,"Local execution clients should be assumed to not have as many resources available (as it helps decentralization to not require it up front) and will likely only build on top of one head in response to an appropriate ",(0,i.kt)("inlineCode",{parentName:"p"},"engine_forkchoiceUpdated")," call. In the worst case, a local execution client will have to respond to a quick succession of ",(0,i.kt)("inlineCode",{parentName:"p"},"engine_forkchoiceUpdated")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"engine_getPayload")," where they may only have time to build a (nearly) empty execution payload."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"TODO: consider: can motivate all of the earlier material on attestation timing/model by making a stronger tie-in here")),(0,i.kt)("h3",{id:"timing-of-broadcasttiming-of-broadcast"},(0,i.kt)("a",{parentName:"h3",href:"Timing-of-broadcast",title:"Timing-of-broadcast"}),"Timing of broadcast"),(0,i.kt)("p",null,"Proposers have some flexibility in the exact time they release their block to the network. The honest behavior is to produce and then broadcast the block as close to the start of the slot as possible. But it is possible a proposer is behind on this schedule for a number of reasons including a spiking load (e.g. from epoch processing) or simply network latency that increases propagation time."),(0,i.kt)("p",null,"If we consider the situation where a new block reaches only some attesters before the honest attesters are expected to broadcast their own attestations, you can see the possibility for a race condition. There is a lot of nuance here in the interplay between when a block can be accepted against what fraction of the network has attested to what view of the chain, but ultimately a late broadcast can trigger a reorg where all of the prior considerations for block production apply."),(0,i.kt)("p",null,"This feature is worth calling out explicitly because there is an additional incentive post-Merge for a proposer to delay their broadcast as much as possible to allow for the construction of an increasingly more valuable payload. The only real back-pressure for the time being (there are proposals to harden the fork choice to this behavior) is the risk of being orphaned in the event a proposer broadcasting right at the deadline does not make it into enough attesters\u2019 views in time. But assuming you can manage the orphan-risk (i.e. well-capitalized builders) then in the same breath this flexibility can be exploited as an optimization to make more valuable blocks."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"TODO: consider: can motivate all of the earlier material on attestation timing/model by making a stronger tie-in here")),(0,i.kt)("h3",{id:"external-builder-failureexternal-builder-failure"},(0,i.kt)("a",{parentName:"h3",href:"External-builder-failure",title:"External-builder-failure"}),"External builder failure"),(0,i.kt)("p",null,"Proposers who wish to use the external builder network may collect outsized revenue but do take on some additional amount of risk. There are two primary failure modes of this pathway: an availability failure of the provided payloads and simple software failure that prohibit proper functioning in the first place."),(0,i.kt)("p",null,"We saw earlier how proposers enter into a \u201ccommit-reveal\u201d game with builders to prevent stealing of valuable payloads. Proposers take on counterparty risk in this game that the builder will release the transaction set in time for the rest of the network to incorporate the \u201cunblinded\u201d block into their local view. A failure here is tricky to mitigate as a proposer who signs a blinded block cannot make a different block for their slot. Operators of this network can deploy increasingly sophisticated techniques to ensure availability but at the time of the Merge the network relies on a fully trusted model. In the early days, builders with good reputation will be preferred to reduce exposure to this risk."),(0,i.kt)("p",null,"Aside from availability concerns, there could simply be a failure at some point in the interaction between the proposer and the external builder network. In this event, no block would be produced and would result in a liveness fault in the chain. Honest proposers are instructed to build an execution payload in parallel and fall back to this payload after some timeout to mitigate this risk. It is assumed reputable actors in the builder network will have low failure rates but they will never be 0% so the local fallback for proposers is critical to ensure the chain\u2019s liveness."),(0,i.kt)("h2",{id:"conclusionconclusion"},(0,i.kt)("a",{parentName:"h2",href:"Conclusion",title:"Conclusion"}),"Conclusion"),(0,i.kt)("p",null,"We have looked at the end-to-end block production process that gets a transaction from the mempool into the canonical chain. The specifics of the Merge software architecture gave us a canvas to illustrate how the various components are orchestrated and an analysis of the inputs at each stage revealed some nice optimizations to ensure quality block production. The exploration of the honest behavior set the stage for behavior at the edges that any block producer should be aware of when performing their role. Hopefully you feel you understand the process a bit better and that this article can serve as a useful reference."))}u.isMDXComponent=!0}}]);