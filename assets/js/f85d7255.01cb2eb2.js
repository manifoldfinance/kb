"use strict";(self.webpackChunkmanifold_kb=self.webpackChunkmanifold_kb||[]).push([[907],{3905:function(e,t,n){n.d(t,{Zo:function(){return h},kt:function(){return p}});var i=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,i,s=function(e,t){if(null==e)return{};var n,i,s={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var r=i.createContext({}),c=function(e){var t=i.useContext(r),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},h=function(e){var t=c(e.components);return i.createElement(r.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var n=e.components,s=e.mdxType,a=e.originalType,r=e.parentName,h=o(e,["components","mdxType","originalType","parentName"]),d=c(n),p=s,b=d["".concat(r,".").concat(p)]||d[p]||u[p]||a;return n?i.createElement(b,l(l({ref:t},h),{},{components:n})):i.createElement(b,l({ref:t},h))}));function p(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var a=n.length,l=new Array(a);l[0]=d;var o={};for(var r in t)hasOwnProperty.call(t,r)&&(o[r]=t[r]);o.originalType=e,o.mdxType="string"==typeof e?e:s,l[1]=o;for(var c=2;c<a;c++)l[c]=n[c];return i.createElement.apply(null,l)}return i.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3677:function(e,t,n){n.r(t),n.d(t,{assets:function(){return h},contentTitle:function(){return r},default:function(){return p},frontMatter:function(){return o},metadata:function(){return c},toc:function(){return u}});var i=n(7462),s=n(3366),a=(n(7294),n(3905)),l=["components"],o={title:"Sync & The Merge",version:"v1.0"},r="Sync & The Merge",c={unversionedId:"Block-Construction/Block-Sync",id:"Block-Construction/Block-Sync",title:"Sync & The Merge",description:"source//raw.githubusercontent.com/fjl/p2p-drafts/master/merge-sync/merge-sync.md",source:"@site/docs/Block-Construction/Block-Sync.md",sourceDirName:"Block-Construction",slug:"/Block-Construction/Block-Sync",permalink:"/docs/Block-Construction/Block-Sync",draft:!1,editUrl:"https://github.com/manifoldfinance/kb/tree/trunk/docs/Block-Construction/Block-Sync.md",tags:[],version:"current",frontMatter:{title:"Sync & The Merge",version:"v1.0"},sidebar:"docsSidebar",previous:{title:"Block Construction",permalink:"/docs/Block-Construction/blockconstruction-message-ordering"},next:{title:"Finding the Safe Head",permalink:"/docs/Block-Construction/Find-Safe-Head"}},h={},u=[{value:"Definitions",id:"definitions",level:2},{value:"Sync",id:"sync",level:2},{value:"eth2 perspective",id:"eth2-perspective",level:3},{value:"eth1 perspective",id:"eth1-perspective",level:3},{value:"Handling restarts and errors",id:"handling-restarts-and-errors",level:3},{value:"Reorg processing and state availability",id:"reorg-processing-and-state-availability",level:2},{value:"Issues",id:"issues",level:2}],d={toc:u};function p(e){var t=e.components,o=(0,s.Z)(e,l);return(0,a.kt)("wrapper",(0,i.Z)({},d,o,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"sync--the-merge"},"Sync & The Merge"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("a",{parentName:"p",href:"https://raw.githubusercontent.com/fjl/p2p-drafts/master/merge-sync/merge-sync.md"},"source: https://raw.githubusercontent.com/fjl/p2p-drafts/master/merge-sync/merge-sync.md"))),(0,a.kt)("p",null,"*",(0,a.kt)("strong",{parentName:"p"},"*","Warning!","*","*")," This is a work in progress. After initial review, it seems that the sync scheme presented here will not work without modifications. See end of document for known issues and potential solutions. For now, you should read this as a description of the ideal sync algorithm, keeping in mind that it will become more complicated later."),(0,a.kt)("p",null,"In this document, we (the geth team) present our ideas for implementing chain synchronization on the merged eth1 + eth2 chain. After the merge event, eth1 and eth2 clients run in tandem. The eth2 client maintains the connection to the beacon chain and performs fork choice. The eth1 client, a.k.a. the 'execution layer', receives block data from the eth2 client, executes/verifies it and maintains the application state."),(0,a.kt)("p",null,"The interface that eth2 and eth1 use to communicate is uni-directional: all cross-client communication is initiated by eth2, and happens in the form of requests. Eth1 responds to requests, but cannot request any information from eth2."),(0,a.kt)("h2",{id:"definitions"},"Definitions"),(0,a.kt)("p",null,"In the text below, we refer to beacon chain blocks as b",(0,a.kt)("sub",null,"x"),". We also assume that the beacon chain begins at block b",(0,a.kt)("sub",null,"W"),", a recent checkpoint, which must be a block after the merge event. There is a direct correspondence between beacon chain blocks and block data of the execution layer: for every beacon block b",(0,a.kt)("sub",null,"x")," (for x >= w), a corresponding execution-layer block B",(0,a.kt)("sub",null,"x")," also exists. Additionally, every execution-layer block B",(0,a.kt)("sub",null,"x")," contains its block header H",(0,a.kt)("sub",null,"x"),"."),(0,a.kt)("p",null,"Please note that this document is an abstract description of the sync algorithm and isn't concerned with the real APIs that eth1 and eth2 nodes will use to communicate. We assume that eth2 can invoke the following operations in the eth1 client:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"checkpoint(H):")," notifies the eth1 client about a checkpoint header. This has no useful response."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"final(B):")," submits a finalized block. The eth1 client can answer 'old', 'syncing', invalid(B) or synced(B). Note that we assume this will be called for all finalized blocks, not just on epoch boundaries."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"proc(B):")," submits a non-finalized block for EVM processing. The eth1 client can respond with 'valid', 'invalid' or 'syncing'.")),(0,a.kt)("p",null,"In diagrams, not all responses to eth2 requests are shown."),(0,a.kt)("h2",{id:"sync"},"Sync"),(0,a.kt)("h3",{id:"eth2-perspective"},"eth2 perspective"),(0,a.kt)("p",null,"This section explains the sync procedure from the eth2 client point-of-view."),(0,a.kt)("p",null,"When the eth2 client starts, it is initialized with a 'weak subjectivity checkpoint' containing the beacon chain state of a historical block b",(0,a.kt)("sub",null,"W"),". The checkpoint also contains the execution-layer block header H",(0,a.kt)("sub",null,"W"),". On startup, H",(0,a.kt)("sub",null,"W")," is immediately relayed to the eth1 client (1)."),(0,a.kt)("p",null,"To sync, the eth2 client must first process the beacon chain optimistically","\u2014","without accessing application state","\u2014","up to the latest finalized block b",(0,a.kt)("sub",null,"F")," (2). When block b",(0,a.kt)("sub",null,"F")," is reached, the eth2 client starts eth1 sync by providing the execution-layer block B",(0,a.kt)("sub",null,"F")," to the eth1 client (3)."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"img",src:n(4788).Z,title:"Syncing up to the latest finalized block",width:"730",height:"156"})),(0,a.kt)("p",null,"The eth2 client keeps following the beacon chain until eth1 sync completes, and keeps submitting finalized blocks to the eth1 client. This means it should repeat step (3) for every new finalized block."),(0,a.kt)("p",null,"Eth1 sync will usually take quite a bit of time to complete. While it is syncing, the beacon chain advances by t blocks to the latest finalized block b",(0,a.kt)("sub",null,"F+t"),"."),(0,a.kt)("p",null,"The eth1 client signals that it is done by responding with synced(B",(0,a.kt)("sub",null,"F+t"),") (4). The application state of B",(0,a.kt)("sub",null,"F+t")," is now available and the eth2 client can perform additional cross-validation against this state. For example, it could read the deposit contract here."),(0,a.kt)("p",null,"The eth2 client should now submit the execution-layer block data of all non-finalized beacon blocks to the eth1 client for processing (5). The sync procedure completes when the current head block b",(0,a.kt)("sub",null,"H")," is reached."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"img",src:n(3643).Z,title:"Processing non-finalized blocks",width:"730",height:"156"})),(0,a.kt)("h3",{id:"eth1-perspective"},"eth1 perspective"),(0,a.kt)("p",null,"Upon startup, the eth1 client first waits for a checkpoint header H",(0,a.kt)("sub",null,"W")," from the eth2 client. H",(0,a.kt)("sub",null,"W")," must be a descendant of the genesis block B",(0,a.kt)("sub",null,"G"),"."),(0,a.kt)("p",null,"Sync begins when the finalized block B",(0,a.kt)("sub",null,"F")," is received. This block is assumed to be valid. Furthermore, it is assumed that B",(0,a.kt)("sub",null,"F")," is a descendant of B",(0,a.kt)("sub",null,"W"),"."),(0,a.kt)("p",null,"While the chain is downloading/processing, the eth1 client receives further notifications about newly-finalized blocks in range B",(0,a.kt)("sub",null,"F+1"),"\u2026","B",(0,a.kt)("sub",null,"F+t"),". During sync, at latest finalized block B",(0,a.kt)("sub",null,"f"),", clients must handle final(B",(0,a.kt)("sub",null,"x"),") as follows:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"for x <= f, the response is 'old' if the block is known, or invalid(B",(0,a.kt)("sub",null,"x"),") if the block is unknown."),(0,a.kt)("li",{parentName:"ul"},"for x > f+1, attempting to finalize an unknown future block, sync is restarted on B",(0,a.kt)("sub",null,"x")," and the response is 'syncing'."),(0,a.kt)("li",{parentName:"ul"},"for x == f+1, the block is appended to the database. If the client is still busy syncing to B",(0,a.kt)("sub",null,"f"),", the response is 'syncing'. If the client is done syncing to block B",(0,a.kt)("sub",null,"f"),", it processes block B",(0,a.kt)("sub",null,"x")," and outputs synced(B",(0,a.kt)("sub",null,"x"),") or invalid(B",(0,a.kt)("sub",null,"x"),").")),(0,a.kt)("p",null,"When proc() is received during sync, the response is 'syncing'."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"img",src:n(1723).Z,title:"Downloading the finalized eth1 chain",width:"730",height:"173"})),(0,a.kt)("p",null,"After starting sync on B",(0,a.kt)("sub",null,"F")," (1), the eth1 client first downloads the chain of block headers down from H",(0,a.kt)("sub",null,"F"),", following parent hashes (2). Headers are written to the database. The header chain must contain the checkpoint header H",(0,a.kt)("sub",null,"W"),", and sync fails if a different header is encountered at the same block number. This sanity check exists to ensure that the chain is valid without having to sync all the way back to the genesis block."),(0,a.kt)("p",null,"When the genesis header H",(0,a.kt)("sub",null,"G")," is reached, block body data can be downloaded (3). There are two ways to do this:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"The client can perform 'full sync', downloading blocks and executing their state transitions. This recreates the application state incrementally up to the latest block. Sync is complete when the latest finalized block B",(0,a.kt)("sub",null,"F+t")," has been processed.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"The client can perform state synchronization by downloading the blocks B",(0,a.kt)("sub",null,"G+1"),"\u2026","B",(0,a.kt)("sub",null,"F")," and their application state without EVM execution. This is expected to be faster than full sync, and is equally secure because the state root of B",(0,a.kt)("sub",null,"F")," was finalized by eth2. The state download can happen concurrently with steps (2) and (3)."),(0,a.kt)("p",{parentName:"li"},"The peer-to-peer network can only provide the state of very recent blocks. Since it is expected that the state of B",(0,a.kt)("sub",null,"F")," will gradually become unavailable as the chain advances, the client must occasionally re-target its state sync to a more recent 'pivot block'. Conveniently, the newly-finalized blocks B",(0,a.kt)("sub",null,"F+1"),"\u2026","B",(0,a.kt)("sub",null,"F+t")," received from eth2 can be used for this purpose. You can read more about the pivot block in the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/ethereum/devp2p/blob/master/caps/snap.md#synchronization-algorithm"},"snap sync protocol specification"),"."))),(0,a.kt)("p",null,"After reporting sync completion of B",(0,a.kt)("sub",null,"F+t")," to the eth2 client (4), the execution layer is done and switches to its ordinary mode of operation: individual blocks are received from the eth2 client, the blocks are processed, and their validity reported back to the eth2 client. Reorgs of non-finalized blocks may also be triggered after sync has completed. Reorg handling is discussed later in this document."),(0,a.kt)("h3",{id:"handling-restarts-and-errors"},"Handling restarts and errors"),(0,a.kt)("p",null,"The above description of sync focuses on a single sync cycle. In order to be robust against failures, and to handle client restarts, clients must be able to perform multiple sync cycles with an initialized database. The interface between eth2 and eth1 makes this easy for eth2 because it is uni-directional: When eth2 restarts, it can simply perform the usual request sequence and expect that the eth1 client will reset itself to the correct state."),(0,a.kt)("p",null,"When eth1 receives note of a finalized block B",(0,a.kt)("sub",null,"F"),", there are two possibilities: if the block already exists in the local chain, and its application state is also available, sync isn't necessary. If the finalized block is unknown, the eth1 client should restart sync at step (1), downloading parent headers in reverse. If the block is known but its state is unavailable, the client should attempt to synchronize the state of B",(0,a.kt)("sub",null,"F")," or, when configured for full sync, attempt to process blocks forward up to B",(0,a.kt)("sub",null,"F")," from the most recent available state."),(0,a.kt)("p",null,"For eth1 sync restarts, block data persisted to the database by previous sync cycles can be reused. Whenever a finalized header H",(0,a.kt)("sub",null,"x")," is to be fetched from the network, the client should check if the database already contains block data at the same block height x. If the local database contains a finalized header at height x, but its hash does not match H",(0,a.kt)("sub",null,"x"),", the client should delete the header and all block data associated with it. If the hash of the previously-stored header does match H",(0,a.kt)("sub",null,"x"),", sync can skip over the chain of locally available headers and resume sync at the height of the next unavailable header."),(0,a.kt)("p",null,"To make this skipping operation work efficiently, we recommend that clients store and maintain 'marker' records containing information about previously-stored contiguous chain segments. When sync starts at H",(0,a.kt)("sub",null,"F"),", the client stores marker M",(0,a.kt)("sub",null,"F")," = F. As subsequent headers H",(0,a.kt)("sub",null,"x")," are downloaded, the marker is updated to M",(0,a.kt)("sub",null,"F")," = x. Similarly, as the chain is extended forward by concurrent calls to final(B",(0,a.kt)("sub",null,"F+1"),"), the marker also moves forward, i.e. M",(0,a.kt)("sub",null,"F+1")," = M",(0,a.kt)("sub",null,"F")," and M",(0,a.kt)("sub",null,"F")," is deleted."),(0,a.kt)("p",null,"Now assume that the sync cycle terminates unexpectedly at block height s. When the next cycle starts, it first loads marker records of previous sync cycles. As the new cycle progresses downloading parents, it will eventually cross the previous height F. If the header hash matches the previously-stored header H",(0,a.kt)("sub",null,"F"),", the marker can be used to resume sync at height s where the first cycle left off."),(0,a.kt)("h2",{id:"reorg-processing-and-state-availability"},"Reorg processing and state availability"),(0,a.kt)("p",null,"It is common knowledge that the application state of eth1 can become quite large. As such, eth1 clients usually only store exactly one full copy of this state."),(0,a.kt)("p",null,"In order to make state synchronization work, the application state of the latest finalized block B",(0,a.kt)("sub",null,"F")," must be available for download. We therefore recommend that clients which store exactly one full copy of the state should store the state of B",(0,a.kt)("sub",null,"F"),"."),(0,a.kt)("p",null,"For the tree of non-finalized blocks beyond B",(0,a.kt)("sub",null,"F"),", the state diff of each block can be held in main memory. As new blocks are finalized, the client applies their diffs to the database, moving the persistent state forward. Storing diffs in memory allows for efficient reorg processing: when the eth2 client detects a reorg from block b",(0,a.kt)("sub",null,"x")," to block b",(0,a.kt)("sub",null,"y"),", it first determines the common ancestor b",(0,a.kt)("sub",null,"a"),". It can then submit all blocks B",(0,a.kt)("sub",null,"a+1"),"\u2026","B",(0,a.kt)("sub",null,"y")," for processing. When the eth1 client detects that a block has already been processed because its state is available as a diff in memory, it can skip EVM processing of the block and just move its head state reference to the new block."),(0,a.kt)("p",null,"While reorgs below B",(0,a.kt)("sub",null,"F")," cannot happen during normal operation of the beacon chain, it may still be necessary to roll back to an earlier state when EVM processing flaws cause the client to deviate from the canonical chain. As a safety net for this exceptional case, we recommend that eth1 clients to maintain a way to manually reorg up to 90,000 blocks (roughly 2 weeks), as this would provide sufficient time to fix issues."),(0,a.kt)("p",null,"To make this 'manual intervention reorg' work, eth1 client can maintain backward diffs in a persistent store. If an intervention is requested, these diffs can be incrementally applied to the state of B",(0,a.kt)("sub",null,"F"),", resetting the client to an earlier state."),(0,a.kt)("h2",{id:"issues"},"Issues"),(0,a.kt)("p",null,"In early review of this scheme, two issues were discovered. Both stem from our misunderstanding of eth2 finalization semantics."),(0,a.kt)("p",null,"(1) Since eth2 finalizes blocks only on epoch boundaries, it wants to call final(B) only for epoch blocks. This could be handled a bit better by also using proc(B) in the sync trigger."),(0,a.kt)("p",null,"(2) While finalization will work within ~64 blocks in the happy case, it can take up to 2 weeks to finalize in the event of a network partition. Since the maximum number of non-finalized blocks is so much larger than we initially anticipated, it will not be possible to use B",(0,a.kt)("sub",null,"F")," as the persistent state block."),(0,a.kt)("p",null,"We have decided to tackle this issue in the following way:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"At head H, define the 'calcified' block B",(0,a.kt)("sub",null,"C")," with C = max(H-512, F). This puts an upper bound of 512 blocks on the number of states kept in memory."),(0,a.kt)("li",{parentName:"ul"},"Define that clients should keep the state of B",(0,a.kt)("sub",null,"C")," in persistent storage."),(0,a.kt)("li",{parentName:"ul"},"Use B",(0,a.kt)("sub",null,"C")," as the initial sync target. This has implications on the sync trigger because the eth1 client can no longer rely on final(B) to start sync (B",(0,a.kt)("sub",null,"C")," may be non-final)."),(0,a.kt)("li",{parentName:"ul"},"Add a new call ","*",(0,a.kt)("strong",{parentName:"li"},"*","reset(B)","*","*")," to reset the eth1 client to a historical block. Require that clients must be able to satisfy any reset in range B",(0,a.kt)("sub",null,"F"),"\u2026","B",(0,a.kt)("sub",null,"H"),". They will probably have to implement something like the persistent reverse diffs recommended in the reorg section.")),(0,a.kt)("p",null,"Adding the calcified block also adds some tricky new corner cases and failure modes. In particular, if the eth1 client just performed snap sync, it will not be able to reorg below B",(0,a.kt)("sub",null,"C"),", because reverse diffs down to B",(0,a.kt)("sub",null,"F")," will not be available. We may solve this by recommending that nodes should attempt snap sync if reset(B) cannot be satisfied. For sure, some nodes will be synced enough to serve the target state. In the absolute worst case, we need to make reverse diffs available for download in snap sync."))}p.isMDXComponent=!0},4788:function(e,t,n){t.Z=n.p+"assets/images/beacon-1-f91d2bb2d8e892ff33ae3dc13d0ee56e.svg"},3643:function(e,t,n){t.Z=n.p+"assets/images/beacon-2-d79dd254057c8889c537a46a4478a739.svg"},1723:function(e,t,n){t.Z=n.p+"assets/images/eth1-1-4afd6760446e444546734d79d5ed531b.svg"}}]);